#!/usr/bin/env python3
#
# omxplayer-sync
#
# Copyright 2016, Simon Josi
# Simon Josi me(at)yokto(dot)net
#
# This program is free software; you can redistribute
# it and/or modify it under the terms of the GNU
# General Public License version 3 as published by
# the Free Software Foundation.
#

import re
import os
import sys
import math
import socket
import signal
import subprocess
import dbus
import getpass
import itertools
import collections
from datetime import datetime
from time import sleep, time
from optparse import OptionParser, BadOptionError, AmbiguousOptionError
try:
    from subprocess import DEVNULL
except ImportError:
    import os
    DEVNULL = open(os.devnull, 'wb')

SYNC_FREQ = 0.5
SYNC_TOLERANCE = .03
SYNC_GRACE_TIME = 3
SYNC_JUMP = 1
SYNC_SMOOTHING = 10

OMXPLAYER = 'omxplayer'
OMXPLAYER_DBUS_ADDR='/tmp/omxplayerdbus.%s' % getpass.getuser()
PORT = 1666

#
# Utils
#

def _print(message, end='\n'):
    now = datetime.now()
    print("[{}] {}".format(now, message), end=end)

def _seconds_to_duration(seconds):
    ss = int(seconds) % (24 * 3600)
    hh = ss // 3600
    ss %= 3600
    mm = ss // 60
    ss %= 60
    return hh, mm, ss

#
# Unknown option pass-through OptionParser
#
class PassThroughOptionParser(OptionParser):
    """
    An unknown option pass-through implementation of OptionParser.

    When unknown arguments are encountered, bundle with largs and try again,
    until rargs is depleted.

    sys.exit(status) will still be called if a known argument is passed
    incorrectly (e.g. missing arguments or bad argument types, etc.)
    """
    def _process_args(self, largs, rargs, values):
        while rargs:
            try:
                OptionParser._process_args(self,largs,rargs,values)
            except (BadOptionError,AmbiguousOptionError) as e:
                largs.append(e.opt_str)

#
# D-Bus player interface
#
class PlayerInterface():
    def _get_dbus_interface(self):
        try:
            bus = dbus.bus.BusConnection(
                open(OMXPLAYER_DBUS_ADDR).readlines()[0].rstrip())
            proxy = bus.get_object(
                'org.mpris.MediaPlayer2.omxplayer',
                '/org/mpris/MediaPlayer2',
                introspect=False)
            self.methods = dbus.Interface(
                proxy, 'org.mpris.MediaPlayer2.Player')
            self.properties = dbus.Interface(
                proxy, 'org.freedesktop.DBus.Properties')
            return True
        except Exception as e:
#            _print("WARNING: dbus connection could not be established")
#            print(e)
#            sleep(5)
            return False

    def initialize(self):
        while not self._get_dbus_interface():
            sleep(0.1)
        while not self.Position():
            sleep(0.1)
        return self._get_dbus_interface()

    def playPause(self):
        try:
            self.methods.Action(16)
            return True
        except:
            print(e)
            return False

    def setPosition(self, seconds):
        try:
            self.methods.SetPosition(
                dbus.ObjectPath('/not/used'),
                dbus.Int64(seconds * 1000000))
        except Exception as e:
            print(e)
            return False

        return True

    def Position(self):
        try:
            return self.properties.Get(
                'org.mpris.MediaPlayer2.Player',
                'Position')
        except Exception as e:
            return False

#
# OMXPlayer-Sync main class
#
class OMXPlayerSync():
    def __init__(self):
        self.sock = self.init_socket()
        self.controller = PlayerInterface()

        self.options = None
        self.omxplayer_options = []
        self.playlist = []
        self.playlist_index = 0
        self.filename = ''
        self.position_local = 0.0
        self.position_local_oldage = 0.0
        self.position_local_oldage_count = 0
        self.position_master = 0.0
        self.filename_master = ''
        self.process = None
        self.acceleration = 0

        signal.signal(signal.SIGINT, self.kill_omxplayer_and_exit)

    def run(self):
        p = PassThroughOptionParser()
        p.add_option('--master', '-m', action='store_true')
        p.add_option('--slave', '-l', action='store_true')
        p.add_option('--destination', '-x', default='255.255.255.255')
        p.add_option('--loop', '-u', action='store_true')
        p.add_option('--verbose', '-v', action='store_true')
        p.add_option('--debug', '-d', action='store_true')
        p.add_option('--adev', '-o', default='both')
        p.add_option('--aspect', '-a', default=None, help="Aspect Mode - fill, letterbox, stretch")
        self.options, arguments = p.parse_args()

        for argument in arguments:
            if argument.startswith('-') or not os.path.isfile(argument):
                self.omxplayer_options.append(argument)
            else:
                self.playlist.append(argument)

        if not len(self.playlist):
            sys.exit(0)
           
        if self.options.loop and len(self.playlist) == 1:
            self.omxplayer_options.append("--loop")
            
        if self.options.aspect in ('fill', 'stretch', 'letterbox'):
            self.omxplayer_options.append("--aspect-mode %s" % self.options.aspect)

        if not filter(lambda x: os.path.isfile(x), self.playlist):
            _print("ERROR: none of the supplied filenames are found")
            sys.exit(1)

        self.omxplayer_options.append("-o %s" % self.options.adev)

        if self.options.debug:
            self.options.verbose = True

        if not self.options.debug:
            self.omxplayer_options.append('--no-osd')

        if self.options.master:
            self.socket_enable_broadcast()
            self.socket_connect(self.options.destination)

        if self.options.slave:
            self.read_position_master()
            self.set_playlist_index()

        while True:
            self.play_file(self.playlist[self.playlist_index])
            if not self.options.loop and self.playlist_index == 0:
                break

    def play_file(self, filename):
        if not os.path.isfile(filename):
            if self.options.verbose:
                _print("WARNING: %s file not found" % filename)
            self.increment_playlist_index()
            return

        self.filename = filename
        self.position_local = 0.0
        self.position_local_oldage = 0.0
        self.position_local_oldage_count = 0

        if self.options.master:
            self.send_position_local()

        self.process = subprocess.Popen([OMXPLAYER] \
            + list(itertools.chain(*map(lambda x: x.split(' '), self.omxplayer_options))) \
            + [self.filename],
            preexec_fn=os.setsid, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE, bufsize=0)
        
        self.controller.initialize()

        if not self.read_position_local():
            _print("WARNING: omxplayer did not start. Try to test with `omxplayer -s OPTIONS`")
            self.kill_omxplayer_and_exit()

        if self.options.slave:
            last_sync = time()
            deviations = collections.deque(maxlen=SYNC_SMOOTHING)

        if self.options.verbose:
            first_frame = True

        while True:
            if self.options.slave:
                self.read_position_master()

            if not self.read_position_local():
                self.increment_playlist_index()
                break

            if self.hangup_detected():
                break

            if self.options.master:
                self.send_position_local()
                if self.options.verbose:
                    hh, mm, ss = _seconds_to_duration(self.position_local)
                    if not ss and not mm and not hh:
                        if first_frame:
                            _print('{}{:33}'.format(self.filename, ''))
                            first_frame = False
                    else:
                        _print('{} ~ {:02d}:{:02d}:{:02d}'.format(self.filename, hh, mm, ss), end='\r')
                        first_frame = True

            if self.options.slave:

                deviation = self.position_master - self.position_local
                deviations.append(deviation)
                median_deviation = self.median(list(deviations))
                #latest_deviation = deviations[-1]

                if self.filename != self.filename_master:
                    self.set_playlist_index()
                    break

                if self.options.verbose:
                    hh, mm, ss = _seconds_to_duration(self.position_local)
                    if not ss and not mm and not hh:
                        if first_frame:
                            _print('{}{:33}'.format(self.filename, ''))
                            first_frame = False
                    else:
                        if not self.acceleration or not self.options.debug:
                            _print('{} ~ {:02d}:{:02d}:{:02d} ~ {:.3f}s [{:d}] {:10}'.format(self.filename, hh, mm, ss, median_deviation, len(deviations), '→' if self.acceleration > 0 else ('←' if self.acceleration < 0 else '⏵')), end='\r')
                        first_frame = True

                #
                # Grace time between syncs
                #
                    
                if last_sync:
                    if (time() - last_sync) > SYNC_GRACE_TIME:
                         last_sync = False

                    continue

                #
                # Syncing 
                #

                # Big diff, jump to proximity
                if abs(median_deviation) > SYNC_JUMP:

                    if not self.controller.setPosition(self.position_master):
                        break

                    self.reset_speed()
                    if self.options.debug:
                        print('')
                        print('')
                        _print('[{:.3f} {} {}]'.format(median_deviation, 'jump, reset_speed()', self.acceleration))
                        print('')
                    last_sync = time()
                    deviations.clear()

                    if self.options.verbose:
                        _print('{} ~ {:02d}:{:02d}:{:02d} → '.format(self.filename, hh, mm, ss), end='')
                        hh, mm, ss = _seconds_to_duration(self.position_master)
                        print('{:02d}:{:02d}:{:02d} {:10}'.format(hh, mm, ss, ''))

                # Small diff, compensate with speed
                elif abs(median_deviation) > SYNC_TOLERANCE and not self.acceleration:
                    
                    if self.options.debug:
                        print('')
                        print('')

                    # Start speed control
                    if median_deviation > 0:
                        self.speed_up()
                        if self.options.debug:
                            _print('[{:.3f} {} {}]'.format(median_deviation, 'speed_up()', self.acceleration))

                    else:
                        self.slow_down()
                        if self.options.debug:
                            _print('[{:.3f} {} {}]'.format(median_deviation, 'slow_down()', self.acceleration))

                # Are we sync yet?
                else:

                    # Speed control in progress
                    if self.acceleration:

                        # If...
                        if (
                            # We have enought data to work with
                            len(deviations) > 2
                            and
                            (
                                # Last 2 deviations are with opposite signs,
                                # then we have just crossed ground zero
                                (deviations[-1] * deviations[-2]) < 0
#                                or
                                # Last deviation is bigger than the one before,
                                # then we missed the ground zero
#                                abs(deviations[-1]) > abs(deviations[-2])
                            )
                        ):
                            self.reset_speed()
                            if self.options.debug:
                                _print('[{:.3f} ~ {:.3f} {:.3f} ~ {} {}]'.format(median_deviation, deviations[-1], deviations[-2], 'sync, reset_speed()', self.acceleration))
                                print('')
                            last_sync = time()
                            deviations.clear()
                        
                        else:
                            if self.options.debug:
                                _print('[{:.3f} ~ {:.3f} {:.3f} ~ {} {}]'.format(median_deviation, deviations[-1], deviations[-2], self.acceleration, len(deviations)))
                        # Endif

            if self.options.master:
                sleep(SYNC_FREQ)

        # Endwhile
        if self.options.slave:
            self.reset_speed()

        if self.options.debug:
            print('')

            if self.options.slave:
                _print('[{:.3f} {} {}]'.format(median_deviation, 'end, reset_speed()', self.acceleration))

        self.kill_omxplayer()

    def slow_down(self):
        self.process.stdin.write('1'.encode()) 
        self.acceleration = -1 if not self.acceleration else 0

    def speed_up(self):
        self.process.stdin.write('2'.encode())
        self.acceleration = 1 if not self.acceleration else 0

    def reset_speed(self):
        if self.acceleration > 0:
            self.slow_down()
        elif self.acceleration < 0:
            self.speed_up()

    def read_position_local(self):
        position_local = self.controller.Position()
        if position_local:
            self.position_local = float(position_local)/1000000
        else:
            return False

        return True

    def set_playlist_index(self):
        if self.filename_master == '':
            _print("WARNING: unable to get current filename from master")
            sleep(5)
            return

        try:
            self.playlist_index = self.playlist.index(self.filename_master)
        except:
            _print("WARNING: current master file '%s' is unavailable" % self.filename_master)

    def increment_playlist_index(self):
        if len(self.playlist) == (self.playlist_index + 1):
            self.playlist_index = 0
        else:
            self.playlist_index += 1

    def hangup_detected(self):
        self.position_local_oldage_count += 1
        if self.position_local_oldage_count == 200:
            if self.position_local_oldage == self.position_local:
                return True

            self.position_local_oldage = self.position_local
            self.position_local_oldage_count = 0

        return False

    def init_socket(self):
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, 0)
        sock.bind(('0.0.0.0', PORT))
        return sock

    def kill_omxplayer(self):
        try:
            os.killpg(os.getpgid(self.process.pid), signal.SIGTERM)
        except:
            pass
        try:
            self.process.wait()
        except:
            pass

    def kill_omxplayer_and_exit(self, *args):
        self.kill_omxplayer()
        sys.exit(0)

    #
    # master specific
    #
    def socket_enable_broadcast(self):
        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)

    def socket_connect(self, destination):
        try:
            self.sock.connect((destination, PORT))
        except:
            _print("connect: Network is unreachable")
            pass

    def send_position_local(self):
        try:
            self.sock.send(("%s%%%s" % (str(self.position_local),  self.filename)).encode('utf-8'))
        except socket.error:
            pass

    #
    # slave specific
    #
    def read_position_master(self):
        data = self.sock.recvfrom(1024)[0].decode('utf-8').split('%', 1)
        self.position_master = float(data[0])
        self.filename_master = data[1]

    def median(self, lst):
        quotient, remainder = divmod(len(lst), 2)
        if remainder:
            return sorted(lst)[quotient]
        return float(sum(sorted(lst)[quotient - 1:quotient + 1]) / 2.0)

if __name__ == '__main__':
    OMXPlayerSync().run()
